<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Predicción Climática</title>
  <link rel="stylesheet" href="/static/css/styles.css">
  <style>
    select {
      margin: 8px 0;
      padding: 5px;
      font-size: 1em;
    }
  </style>
</head>
<body>
  <header>
    <a href="/"><img src="/static/weather.png" alt="Logo" class="logo"></a>
    <h1>Predicción de datos del clima</h1>
  </header>
  <main>
    <div class="container">
      <div class="div_predicciones">

        <!-- DATOS SENSOR -->
        <div>
          <h2>Datos percibidos (sensor)</h2>
          <div class="card">
            <table class="table">
              <thead><tr><th>Métrica</th><th>Valor</th><th>Unidad</th></tr></thead>
              <tbody>
                <tr><td>Temperatura</td><td>-</td><td>°C</td></tr>
                <tr><td>Humedad</td><td>-</td><td>%</td></tr>
                <tr><td>Presión</td><td>-</td><td>hPa</td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <!-- DATOS PREDECIDOS -->
        <div>
          <h2>Predicciones futuras</h2>
          <label class="select-label" for="horasSelect">Predecir hasta:</label>
          <select id="horasSelect">
            <option value="1">1 hora</option>
            <option value="2">2 horas</option>
            <option value="3">3 horas</option>
            <option value="4">4 horas</option>
            <option value="5">5 horas</option>
            <option value="6" selected>6 horas</option>
          </select>
          <button id="btnPredecir">Generar predicciones</button>
          <div id="statusMessage" style="margin-top: 10px; font-weight: bold;"></div>

          <div class="card">
            <table class="table" id="tabla_predicciones">
              <thead><tr><th>Hora (+)</th><th>Temperatura (°C)</th></tr></thead>
              <tbody></tbody>
            </table>
          </div>
        </div>

      </div>
    </div>
  </main>

  <script>
  async function fetchLatestSensor() {
    try {
      const resp = await fetch('/api/sensor/latest?limit=1');
      const data = await resp.json();
      if (data && data.length) {
        const latest = data[0];
        const card = document.querySelectorAll('.div_predicciones .card')[0];
        card.querySelectorAll('tbody tr')[0].cells[1].innerText = latest.temperatura.toFixed(2);
        card.querySelectorAll('tbody tr')[1].cells[1].innerText = latest.humedad.toFixed(2);
        card.querySelectorAll('tbody tr')[2].cells[1].innerText = latest.presion ? latest.presion.toFixed(2) : '-';
      }
    } catch (e) {
      console.error('Error fetchLatestSensor', e);
      // Mostrar error visual en la tabla
      const card = document.querySelectorAll('.div_predicciones .card')[0];
      card.querySelectorAll('tbody tr').forEach(row => {
        row.cells[1].innerText = 'Error';
      });
    }
  }

  async function fetchFuturePredictions(limit) {
    try {
      // Las predicciones están minuto a minuto, necesitamos 60 * horas
      const minutosNecesarios = limit * 60;
      const resp = await fetch(`/api/predictions/future?limit=${minutosNecesarios}`);
      const data = await resp.json();
      const tbody = document.querySelector('#tabla_predicciones tbody');
      tbody.innerHTML = '';
      
      if (data && data.length >= minutosNecesarios) {
        // Agrupar por hora (promediar cada 60 minutos)
        const horasAgrupadas = [];
        for (let hora = 0; hora < limit; hora++) {
          const inicioIdx = hora * 60;
          const finIdx = inicioIdx + 60;
          const minutosHora = data.slice(inicioIdx, finIdx);
          
          if (minutosHora.length === 60) {
            // Calcular promedio de temperatura de esa hora
            const tempPromedio = minutosHora.reduce((sum, pred) => sum + pred.temperatura_pred, 0) / 60;
            horasAgrupadas.push({
              hora: hora + 1,
              temperatura_promedio: tempPromedio
            });
          }
        }
        
        // Mostrar las horas agrupadas
        if (horasAgrupadas.length > 0) {
          horasAgrupadas.forEach((horaData) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td>+${horaData.hora} h</td>
              <td>${horaData.temperatura_promedio.toFixed(2)}</td>
            `;
            tbody.appendChild(tr);
          });
        } else {
          tbody.innerHTML = '<tr><td colspan="2">Datos insuficientes</td></tr>';
        }
      } else {
        // No hay suficientes predicciones para las horas solicitadas
        tbody.innerHTML = `<tr><td colspan="2">Sin predicciones para ${limit} horas (solo hay ${Math.floor(data.length / 60)} horas disponibles)</td></tr>`;
      }
    } catch (e) {
      console.error('Error fetchFuturePredictions', e);
      const tbody = document.querySelector('#tabla_predicciones tbody');
      tbody.innerHTML = '<tr><td colspan="2">Error al cargar predicciones</td></tr>';
    }
  }

  async function runPrediction(horas) {
    const statusDiv = document.getElementById('statusMessage');
    const btnPredecir = document.getElementById('btnPredecir');
    
    try {
      // 1. Limpiar tabla de predicciones visualmente
      const tbody = document.querySelector('#tabla_predicciones tbody');
      if (tbody) {
        tbody.innerHTML = '<tr><td colspan="2">Generando predicciones...</td></tr>';
      }
      
      statusDiv.style.color = '#2196F3';
      statusDiv.innerText = '🔄 Generando predicciones...';
      btnPredecir.disabled = true;
      
      const resp = await fetch('/api/predict', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ horas_futuro: horas })
      });
      const result = await resp.json();
      console.log(result.message);
      
      statusDiv.innerText = '⏳ Procesando datos... Esto puede tardar varios minutos en Raspberry Pi';
      
      // Polling inteligente: revisar cada 5 segundos hasta 60 intentos (5 minutos total)
      let attempts = 0;
      const maxAttempts = 60; // 60 intentos
      const checkInterval = 5000; // 5 segundos
      let lastCheckTime = null;
      
      const checkPredictions = async () => {
        attempts++;
        
        try {
          const respAfter = await fetch('/api/predictions/future?limit=1');
          const dataAfter = await respAfter.json();
          const countAfter = dataAfter.length;
          const currentPredictionTime = dataAfter.length > 0 ? dataAfter[0].prediction_time : null;
          
          // Verificar si hay predicciones nuevas
          // Como limpiamos la tabla antes, simplemente verificamos si existen predicciones
          const hasNewPredictions = countAfter > 0 && 
                                    (lastCheckTime === null || currentPredictionTime !== lastCheckTime);
          
          // Actualizar el último tiempo verificado
          if (currentPredictionTime) {
            lastCheckTime = currentPredictionTime;
          }
          
          if (hasNewPredictions) {
            // ¡Éxito! Se generaron predicciones
            await fetchFuturePredictions(horas);
            statusDiv.style.color = '#4CAF50';
            statusDiv.innerText = `✓ Predicciones generadas correctamente (${attempts * 5}s)`;
            btnPredecir.disabled = false;
            
            setTimeout(() => {
              statusDiv.innerText = '';
            }, 5000);
          } else if (attempts >= maxAttempts) {
            // Timeout después de 5 minutos
            statusDiv.style.color = '#f44336';
            statusDiv.innerText = '✗ Tiempo de espera agotado (5 minutos). Revisa los logs del servidor o intenta con menos horas.';
            btnPredecir.disabled = false;
            
            setTimeout(() => {
              statusDiv.innerText = '';
            }, 7000);
          } else {
            // Seguir esperando - mostrar tiempo en formato legible
            const secondsElapsed = attempts * 5;
            const minutesElapsed = Math.floor(secondsElapsed / 60);
            const secondsRemaining = secondsElapsed % 60;
            const timeDisplay = minutesElapsed > 0 
              ? `${minutesElapsed}m ${secondsRemaining}s` 
              : `${secondsElapsed}s`;
            
            statusDiv.innerText = `⏳ Procesando datos... (${timeDisplay} / 5min)`;
            setTimeout(checkPredictions, checkInterval);
          }
        } catch (error) {
          console.error('Error checking predictions:', error);
          if (attempts >= maxAttempts) {
            statusDiv.style.color = '#f44336';
            statusDiv.innerText = '✗ Error al verificar predicciones. Recarga la página.';
            btnPredecir.disabled = false;
          } else {
            setTimeout(checkPredictions, checkInterval);
          }
        }
      };
      
      // Iniciar el primer chequeo después de 10 segundos (dar tiempo inicial para Raspberry Pi)
      setTimeout(checkPredictions, 10000);
      
    } catch (e) {
      console.error('Error runPrediction', e);
      statusDiv.style.color = '#f44336';
      statusDiv.innerText = '✗ Error al generar predicciones: ' + e.message;
      btnPredecir.disabled = false;
      
      setTimeout(() => {
        statusDiv.innerText = '';
      }, 5000);
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const selectHoras = document.getElementById('horasSelect');
    const btnPredecir = document.getElementById('btnPredecir');

    fetchLatestSensor();
    fetchFuturePredictions(parseInt(selectHoras.value));

    // Actualizar la tabla cuando cambie el select
    selectHoras.addEventListener('change', () => {
      const horas = parseInt(selectHoras.value);
      fetchFuturePredictions(horas);
    });

    btnPredecir.addEventListener('click', () => {
      const horas = parseInt(selectHoras.value);
      runPrediction(horas);
    });

    setInterval(() => {
      fetchLatestSensor();
    }, 60 * 1000);
  });
  </script>
</body>
</html>
